<#@ assembly name="System.Linq.dll" #>
<#@ assembly name="System.Xml.dll" #>
<#@ assembly name="System.Xml.Linq.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output encoding="utf-8" extension=".cs" #>
<#@ template compilerOptions="/unsafe+ /warnaserror+" debug="true" hostspecific="true" #>
<#
var root = XDocument.Load(Host.ResolvePath("SyntaxTree.xml")).Root;
var settings = new Settings(root.Element("settings"));
var nodes = root.Element("nodes").Elements().Select(elem => new Node(elem, settings)).ToArray();

WriteLine("// <auto-generated />");
WriteLine(string.Empty);

WriteLine("#nullable enable");
WriteLine(string.Empty);

WriteLine("using System;");
WriteLine("using System.Collections.Generic;");
WriteLine("using System.Collections.Immutable;");
WriteLine("using System.Linq;");
WriteLine(string.Empty);

WriteLine("namespace Flare.Syntax");
WriteLine("{");
PushIndent("    ");

for (var i = 0; i < nodes.Length; i++)
{
    var node = nodes[i];
    var type = node.TypeName;

    WriteLine("public {0} class {1} : {2}", node.IsAbstract ? "abstract" : "sealed", type, node.BaseTypeName);
    WriteLine("{");
    PushIndent("    ");

    var props = node.Properties;

    foreach (var prop in props)
    {
        var attr = string.Empty;

        if (node.IsAbstract)
            attr = " abstract";
        else if (prop.IsOverride)
            attr = " override";

        WriteLine("public{0} {1} {2} {{ get; }}", attr, prop.TypeName, prop.PropertyName);
        WriteLine(string.Empty);
    }

    if (node.IsAbstract)
    {
        WriteLine("private protected {0}(", type);
        PushIndent("    ");
        WriteLine("IReadOnlyList<SyntaxToken> skipped,");
        WriteLine("IReadOnlyList<SyntaxDiagnostic> diagnostics,");
        WriteLine("ImmutableDictionary<string, object> annotations)");
        WriteLine("    : base(skipped, diagnostics, annotations)");
        PopIndent();
        WriteLine("{");
        WriteLine("}");
    }
    else
    {
        var tokens = props.Where(prop => prop.IsToken || prop.IsTokens || (prop.IsChildren && prop.IsSeparated)).ToArray();

        if (tokens.Length == 0)
            WriteLine("public override bool HasTokens => false;");
        else if (tokens.Any(prop => prop.IsToken && !prop.IsOptional))
            WriteLine("public override bool HasTokens => true;");
        else
        {
            WriteLine("public override bool HasTokens");
            WriteLine("{");
            PushIndent("    ");
            WriteLine("get");
            WriteLine("{");
            PushIndent("    ");

            for (var j = 0; j < tokens.Length; j++)
            {
                var prop = tokens[j];
                var name = prop.PropertyName;

                if (prop.IsTokens)
                    WriteLine("if ({0}.Count != 0)", name);
                else if (prop.IsToken)
                    WriteLine("if ({0} != null)", name);

                if (!prop.IsChildren)
                {
                    PushIndent("    ");
                    WriteLine("return true;");
                    PopIndent();
                }

                if (prop.IsSeparated)
                {
                    WriteLine("if ({0}.Separators.Count != 0)", name);
                    PushIndent("    ");
                    WriteLine("return true;");
                    PopIndent();
                }

                if (j != tokens.Length - 1)
                    WriteLine(string.Empty);
            }

            WriteLine(string.Empty);
            WriteLine("return false;");
            PopIndent();
            WriteLine("}");
            PopIndent();
            WriteLine("}");
        }

        WriteLine(string.Empty);

        var children = props.Where(prop => prop.IsChild || prop.IsChildren).ToArray();

        if (children.Length == 0)
            WriteLine("public override bool HasChildren => false;");
        else if (children.Any(prop => prop.IsChild && !prop.IsOptional))
            WriteLine("public override bool HasChildren => true;");
        else
        {
            WriteLine("public override bool HasChildren");
            WriteLine("{");
            PushIndent("    ");
            WriteLine("get");
            WriteLine("{");
            PushIndent("    ");

            for (var j = 0; j < children.Length; j++)
            {
                var prop = children[j];
                var name = prop.PropertyName;

                if (prop.IsChildren)
                    WriteLine("if ({0}.Count != 0)", name);
                else
                    WriteLine("if ({0} != null)", name);

                PushIndent("    ");
                WriteLine("return true;");
                PopIndent();

                if (j != children.Length - 1)
                    WriteLine(string.Empty);
            }

            WriteLine(string.Empty);
            WriteLine("return false;");
            PopIndent();
            WriteLine("}");
            PopIndent();
            WriteLine("}");
        }

        WriteLine(string.Empty);

        WriteLine("internal {0}(", type);
        PushIndent("    ");
        WriteLine("IReadOnlyList<SyntaxToken> skipped,");
        Write("IReadOnlyList<SyntaxDiagnostic> diagnostics");

        if (props.Count != 0)
        {
            WriteLine(",");

            for (var j = 0; j < props.Count; j++)
            {
                var prop = props[j];

                Write("{0} {1}", prop.TypeName, prop.ParameterName);

                if (j == props.Count - 1)
                    Write(")");
                else
                    Write(",");

                WriteLine(string.Empty);
            }
        }
        else
            WriteLine(")");

        WriteLine(": this(");
        PushIndent("    ");
        WriteLine("skipped,");
        WriteLine("diagnostics,");
        Write("ImmutableDictionary<string, object>.Empty");

        if (props.Count != 0)
        {
            WriteLine(",");

            for (var j = 0; j < props.Count; j++)
            {
                Write(props[j].ParameterName);

                if (j == props.Count - 1)
                    Write(")");
                else
                    Write(",");

                WriteLine(string.Empty);
            }
        }
        else
            WriteLine(")");

        PopIndent();
        PopIndent();
        WriteLine("{");
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("{0}(", type);
        PushIndent("    ");
        WriteLine("IReadOnlyList<SyntaxToken> skipped,");
        WriteLine("IReadOnlyList<SyntaxDiagnostic> diagnostics,");
        Write("ImmutableDictionary<string, object> annotations");

        if (props.Count != 0)
        {
            WriteLine(",");

            for (var j = 0; j < props.Count; j++)
            {
                var prop = props[j];

                Write("{0} {1}", prop.TypeName, prop.ParameterName);

                if (j == props.Count - 1)
                    Write(")");
                else
                    Write(",");

                WriteLine(string.Empty);
            }
        }
        else
            WriteLine(")");

        WriteLine(": base(skipped, diagnostics, annotations)");
        PopIndent();
        WriteLine("{");
        PushIndent("    ");

        for (var j = 0; j < props.Count; j++)
        {
            var prop = props[j];
            var param = prop.ParameterName;

            WriteLine("{0} = {1};", prop.PropertyName, param);

            if (prop.IsChildren || prop.IsTokens)
            {
                WriteLine("foreach (var child in {0})", param);
                PushIndent("    ");
                WriteLine("child.Parent = this;");
                PopIndent();

                if (prop.IsSeparated)
                {
                    WriteLine("foreach (var child in {0}.Separators)", param);
                    PushIndent("    ");
                    WriteLine("child.Parent = this;");
                    PopIndent();
                }
            }
            else
            {
                if (prop.IsOptional)
                {
                    WriteLine("if ({0} != null)", param);
                    PushIndent("    ");
                }

                WriteLine("{0}.Parent = this;", param);

                if (prop.IsOptional)
                    PopIndent();
            }

            if (j != props.Count - 1)
                WriteLine(string.Empty);
        }

        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("public {0} DeepClone()", type);
        WriteLine("{");
        PushIndent("    ");
        WriteLine("return new {0}(", type);
        PushIndent("    ");
        WriteLine("SkippedTokens.Select(x => x.DeepClone()).ToArray(),");
        WriteLine("Diagnostics,");
        Write("Annotations");

        if (props.Count != 0)
        {
            WriteLine(",");

            for (var j = 0; j < props.Count; j++)
            {
                var prop = props[j];
                var name = prop.PropertyName;

                if (prop.IsChild)
                {
                    Write("({0}){1}", prop.TypeName, name);

                    if (prop.IsOptional)
                        Write("?");

                    Write(".InternalDeepClone()");
                }
                else
                {
                    Write(name);

                    if (prop.IsOptional)
                        Write("?");

                    Write(".DeepClone()");
                }

                if (j == props.Count - 1)
                    Write(");");
                else
                    Write(",");

                WriteLine(string.Empty);
            }
        }
        else
            WriteLine(");");

        PopIndent();
        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("internal override SyntaxNode InternalDeepClone()");
        WriteLine("{");
        PushIndent("    ");
        WriteLine("return DeepClone();");
        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("public override IEnumerable<SyntaxToken> Tokens()");
        WriteLine("{");
        PushIndent("    ");

        if (tokens.Length != 0)
        {
            for (var j = 0; j < tokens.Length; j++)
            {
                var prop = tokens[j];
                var name = prop.PropertyName;

                if (prop.IsTokens)
                {
                    WriteLine("foreach (var token in {0})", name);
                    PushIndent("    ");
                    WriteLine("yield return token;");
                    PopIndent();
                }
                else if (prop.IsToken)
                {
                    if (prop.IsOptional)
                    {
                        WriteLine("if ({0} != null)", name);
                        PushIndent("    ");
                    }

                    WriteLine("yield return {0};", name);

                    if (prop.IsOptional)
                        PopIndent();
                }

                if (prop.IsSeparated)
                {
                    WriteLine("foreach (var token in {0}.Separators)", name);
                    PushIndent("    ");
                    WriteLine("yield return token;");
                    PopIndent();
                }

                if (j != tokens.Length - 1)
                    WriteLine(string.Empty);
            }
        }
        else
            WriteLine("return Array.Empty<SyntaxToken>();");

        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("public override IEnumerable<SyntaxNode> Children()");
        WriteLine("{");
        PushIndent("    ");

        if (children.Length != 0)
        {
            for (var j = 0; j < children.Length; j++)
            {
                var prop = children[j];
                var name = prop.PropertyName;

                if (prop.IsChildren)
                {
                    WriteLine("foreach (var child in {0})", name);
                    PushIndent("    ");
                    WriteLine("yield return child;");
                    PopIndent();
                }
                else
                {
                    if (prop.IsOptional)
                    {
                        WriteLine("if ({0} != null)", name);
                        PushIndent("    ");
                    }

                    WriteLine("yield return {0};", name);

                    if (prop.IsOptional)
                        PopIndent();
                }

                if (j != children.Length - 1)
                    WriteLine(string.Empty);
            }
        }
        else
            WriteLine("return Array.Empty<SyntaxNode>();");

        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("internal override void Accept(SyntaxVisitor visitor)");
        WriteLine("{");
        PushIndent("    ");
        WriteLine("visitor.Visit(this);");
        PopIndent();
        WriteLine("}");
        WriteLine(string.Empty);

        WriteLine("internal override T Accept<T>(SyntaxVisitor<T> visitor, T state)");
        WriteLine("{");
        PushIndent("    ");
        WriteLine("return visitor.Visit(this, state);");
        PopIndent();
        WriteLine("}");
    }

    PopIndent();
    WriteLine("}");

    if (i != nodes.Length - 1)
        WriteLine(string.Empty);
}

WriteLine(string.Empty);

WriteLine("public partial class SyntaxVisitor");
WriteLine("{");
PushIndent("    ");

for (var i = 0; i < nodes.Length; i++)
{
    var node = nodes[i];

    if (node.IsAbstract)
        continue;

    WriteLine("public virtual void Visit({0} node)", node.TypeName);
    WriteLine("{");
    PushIndent("    ");
    WriteLine("DefaultVisit(node);");
    PopIndent();
    WriteLine("}");

    if (i != nodes.Length - 1)
        WriteLine(string.Empty);
}

PopIndent();
WriteLine("}");
WriteLine(string.Empty);

WriteLine("public partial class SyntaxVisitor<T>");
WriteLine("{");
PushIndent("    ");

for (var i = 0; i < nodes.Length; i++)
{
    var node = nodes[i];

    if (node.IsAbstract)
        continue;

    WriteLine("public virtual T Visit({0} node, T state)", node.TypeName);
    WriteLine("{");
    PushIndent("    ");
    WriteLine("return DefaultVisit(node, state);");
    PopIndent();
    WriteLine("}");

    if (i != nodes.Length - 1)
        WriteLine(string.Empty);
}

PopIndent();
WriteLine("}");

PopIndent();
WriteLine("}");
#>
<#+
sealed class Settings
{
    public string DefaultBaseTypeName { get; }

    public string TypeNameSuffix { get; }

    public Settings(XElement element)
    {
        DefaultBaseTypeName = (string)element.Element("base");
        TypeNameSuffix = (string)element.Element("suffix");
    }
}

sealed class Node
{
    public string TypeName { get; }

    public string BaseTypeName { get; }

    public bool IsAbstract { get; }

    public IReadOnlyList<Property> Properties { get; }

    public Node(XElement element, Settings settings)
    {
        TypeName = (string)element.Attribute("name") + settings.TypeNameSuffix;
        BaseTypeName = ((string)element.Attribute("base") ?? settings.DefaultBaseTypeName) + settings.TypeNameSuffix;
        IsAbstract = (bool?)element.Attribute("abstract") ?? false;
        Properties = element.Elements().Select(elem => new Property(elem, settings)).ToArray();
    }
}

sealed class Property
{
    public bool IsOverride { get; }

    public bool IsToken { get; }

    public bool IsTokens { get; }

    public bool IsChild { get; }

    public bool IsChildren { get; }

    public bool IsSeparated { get; }

    public bool IsOptional { get; }

    public string PropertyName { get; }

    public string ParameterName { get; }

    public string TypeName { get; }

    public Property(XElement element, Settings settings)
    {
        IsOverride = (bool?)element.Attribute("override") ?? false;
        IsToken = element.Name == "token";
        IsTokens = element.Name == "tokens";
        IsChild = element.Name == "child";
        IsChildren = element.Name == "children";
        IsSeparated = (bool?)element.Attribute("separated") ?? false;
        IsOptional = (bool?)element.Attribute("optional") ?? false;

        var prop = (string)element.Attribute("name");

        if (IsToken)
            prop += "Token";
        else if (IsTokens)
            prop += "Tokens";

        PropertyName = prop;

        var param = char.ToLowerInvariant(prop[0]) + prop.Substring(1);

        switch (param)
        {
            case "catch":
            case "else":
            case "operator":
            case "try":
                param = '@' + param;
                break;
        }

        ParameterName = param;

        var type = IsToken || IsTokens ? "SyntaxToken" : (string)element.Attribute("type") + settings.TypeNameSuffix;

        if (IsTokens)
            type = "SyntaxTokenList";
        else if (IsChildren)
            type = $"SyntaxNodeList<{type}>";

        if (IsSeparated)
            type = "Separated" + type;

        if (IsOptional)
            type += '?';

        TypeName = type;
    }
}
#>
